use super::{Align, Bus, Event, Hub, ID_FEEDER, Id, RenderData, RenderQueue, View, ViewId};
use crate::colour::{Colour, TEXT_INVERTED_HARD, TEXT_NORMAL};
use crate::context::Context;
use crate::device::CURRENT_DEVICE;
use crate::document::pdf::PdfOpener;
use crate::font::Fonts;
use crate::framebuffer::{Framebuffer, Pixmap, UpdateMode};
use crate::geom::{CornerSpec, Rectangle};
use crate::input::gestures::GestureEvent;
use crate::input::{DeviceEvent, FingerStatus};
use crate::unit::scale_by_dpi_raw;
use fxhash::FxHashMap;
use std::path::Path;
use std::sync::LazyLock;

const ICON_SCALE: f32 = 1.0 / 32.0;

pub static ICONS_PIXMAPS: LazyLock<FxHashMap<&'static str, Pixmap>> = LazyLock::new(|| {
    let mut m = FxHashMap::default();
    let scale = scale_by_dpi_raw(ICON_SCALE, CURRENT_DEVICE.dpi);
    let dir = Path::new("icons");

    for name in [
        "home",
        "search",
        "back",
        "frontlight",
        "frontlight-disabled",
        "menu",
        "angle-left",
        "angle-right",
        "angle-left-small",
        "angle-right-small",
        "return",
        "shift",
        "combine",
        "alternate",
        "delete-backward",
        "delete-forward",
        "move-backward",
        "move-backward-short",
        "move-forward",
        "move-forward-short",
        "close",
        "check_mark-small",
        "check_mark",
        "check_mark-large",
        "bullet",
        "arrow-left",
        "arrow-right",
        "angle-down",
        "angle-up",
        "crop",
        "toc",
        "font_family",
        "font_size",
        "line_height",
        "align-justify",
        "align-left",
        "align-right",
        "align-center",
        "margin",
        "plug",
        "cover",
        "enclosed_menu",
        "contrast",
        "grey",
    ]
    .iter()
    .cloned()
    {
        let path = dir.join(&format!("{}.svg", name));

        let doc = PdfOpener::new().and_then(|o| o.open(path)).unwrap();
        let pixmap = doc.page(0).and_then(|p| p.pixmap(scale, 1)).unwrap();
        m.insert(name, pixmap);
    }
    m
});

pub struct Icon {
    id: Id,
    pub rect: Rectangle,
    children: Vec<Box<dyn View>>,
    pub name: String,
    background: Colour,
    align: Align,
    corners: Option<CornerSpec>,
    event: Event,
    pub active: bool,
}

impl Icon {
    pub fn new(name: &str, rect: Rectangle, event: Event) -> Icon {
        Icon {
            id: ID_FEEDER.next(),
            rect,
            children: Vec::new(),
            name: name.to_string(),
            background: TEXT_NORMAL[0],
            align: Align::Center,
            corners: None,
            event,
            active: false,
        }
    }

    pub fn background(mut self, background: Colour) -> Icon {
        self.background = background;
        self
    }

    pub fn align(mut self, align: Align) -> Icon {
        self.align = align;
        self
    }

    pub fn corners(mut self, corners: Option<CornerSpec>) -> Icon {
        self.corners = corners;
        self
    }
}

impl View for Icon {
    fn handle_event(
        &mut self,
        evt: &Event,
        hub: &Hub,
        bus: &mut Bus,
        rq: &mut RenderQueue,
        _context: &mut Context,
    ) -> bool {
        match *evt {
            Event::Device(DeviceEvent::Finger {
                status, position, ..
            }) => match status {
                FingerStatus::Down if self.rect.includes(position) => {
                    self.active = true;
                    rq.add(RenderData::new(self.id, self.rect, UpdateMode::Fast));
                    true
                }
                FingerStatus::Up if self.active => {
                    self.active = false;
                    rq.add(RenderData::new(self.id, self.rect, UpdateMode::Gui));
                    true
                }
                _ => false,
            },
            Event::Gesture(GestureEvent::Tap(center)) if self.rect.includes(center) => {
                bus.push_back(self.event.clone());
                true
            }
            Event::Gesture(GestureEvent::HoldFingerShort(center, ..))
                if self.rect.includes(center) =>
            {
                match self.event {
                    Event::Page(dir) => bus.push_back(Event::Chapter(dir)),
                    Event::Show(ViewId::Frontlight) => {
                        hub.send(Event::ToggleFrontlight).ok();
                    }
                    Event::Show(ViewId::MarginCropper) => {
                        bus.push_back(Event::ToggleNear(ViewId::MarginCropperMenu, self.rect));
                    }
                    Event::History(dir, false) => {
                        bus.push_back(Event::History(dir, true));
                    }
                    _ => (),
                }
                true
            }
            _ => false,
        }
    }

    fn render(&self, fb: &mut dyn Framebuffer, _rect: Rectangle, _fonts: &mut Fonts) {
        let scheme = if self.active {
            TEXT_INVERTED_HARD
        } else {
            TEXT_NORMAL
        };

        let pixmap = ICONS_PIXMAPS.get(&self.name[..]).unwrap();
        let dx = self
            .align
            .offset(pixmap.width as i32, self.rect.width() as i32);
        let dy = (self.rect.height() as i32 - pixmap.height as i32) / 2;
        let pt = self.rect.min + pt!(dx, dy);

        let background = if self.active {
            scheme[0]
        } else {
            self.background
        };

        if let Some(ref cs) = self.corners {
            fb.draw_rounded_rectangle(&self.rect, cs, background);
        } else {
            fb.draw_rectangle(&self.rect, background);
        }

        fb.draw_blended_pixmap(pixmap, pt, scheme[1]);
    }

    fn resize(
        &mut self,
        rect: Rectangle,
        _hub: &Hub,
        _rq: &mut RenderQueue,
        _context: &mut Context,
    ) {
        if let Event::ToggleNear(_, ref mut event_rect) = self.event {
            *event_rect = rect;
        }
        self.rect = rect;
    }

    fn rect(&self) -> &Rectangle {
        &self.rect
    }

    fn rect_mut(&mut self) -> &mut Rectangle {
        &mut self.rect
    }

    fn children(&self) -> &Vec<Box<dyn View>> {
        &self.children
    }

    fn children_mut(&mut self) -> &mut Vec<Box<dyn View>> {
        &mut self.children
    }

    fn id(&self) -> Id {
        self.id
    }
}
